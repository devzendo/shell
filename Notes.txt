command [arg1 .. argN]

command1 [args] | command2 [args]               < iterator piping

  first command receives empty-iterator, commands in the middle of the
  pipeline receive their previous command's output iterator, command at the
  end receives a stdout-output-iterator. each command is executed using a
  shellplugin-command-execution-command which looks through the PluginRegistry
  for methods to execute

command "quotes bind | a string"                < quoting

some internal commands and syntactic sugar

command [args] > variable
variable = command [args]
variable = command1 [args] | command2 [args] | ... | commandN [args]
  same as command [args] | varstore variable
  input iterator to varstore is stored as variable in the variable store.
  output iterator to varstore is null-iterator, which ignores all input.
  (haven't implemented varstore yet)

  Can't do var = command > var, as this is ambiguous.

args:
  numbers
  strings
  variable references
  switches
                                              _ buffer-it2 stored in foo var
execution mechanics:                         /
      command1      command2     varstore foo
     /        \    /       \     /          \
empty-it     buffer-it1   buffer-it2        null-it


Scope control
The outermost level is the global scope. Each new { ... } block gets a new
scope, which can have definitions created and used within it. This is
destructed when all commands in the block end. New scopes chain from their
parent; all defns in the chain up to the parent can be seen.

command0 | { command1 | command2 } | { command3       } |   command4
^          ^                     ^    ^               ^      ^
global     scope1>global         |    scope2>global  |      global
                           s1 destructor             |
                                                   s2 destructor

command0 | {        { command1 } }
^          ^        ^
global     |        |
      scope1>global |
                scope2>scope1>global

So, lookups by command1 will first search scope2, then scope1, then global.

command { /* block */ } | { command | command } |

Rough ideas
findFiles -Under /tmp -SuchThat { (_.absolutePath =~ /foo/) && (_.size > 1024MB) }
_ is aliased to refer to the iterator. The block is called foreach file found.
