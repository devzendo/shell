05/07/2016
Picked up again. Split this diary out of Notes.txt.

10/07/2013
Current status: project paused. I want to add an 'implicit eval command', so you
can say x = 4. There's no command involved here, just an assignment of a literal.
However, before I can add this, I need to change the variable reference detector
in the parser to use a partial function that checks for variable reference
existence. This is since when adding eval, the pipeline 'foo' (where foo does
not exist as a command; see the test commandThatIsNotDefined) gets parsed as
'eval <variable reference foo>', which is wrong - it is an unknown command.

Adding this partial function is possible, but how does it know the current
scope? Global is easy, but how can it know that it has to use a variable registry
in the eval command 'x = { z = 5; 2 + z }' (to know where to find z)?


Also, although the language has progressed to almost the point of being useful,
it's pretty hairy, with a few cases that make me wonder whether it is /too weird/,
e.g.
  if false { echo "it is false" }
... works fine, one 'if' command with 'false' as its conditional, and the block as
its 'then block'.

However:
  if (false) { echo "it is false" }
... is parsed as two commands - an 'if' with 'false' as conditional and no
blocks (which is useless, but catered for), and a block pipeline that echoes.
WTF?
The reason this happens is that the parens around the 'false' make the parser
see the call to 'if' as a function, and the block is not inside those parens,
and so the 'if' only has 'false' as its only arg.

So, I tell users, don't put parens around literals. But if you want to use an
expression as the conditional [ (x || y) say ], then you have to.
if (x || y} { echo "truth" } works fine, if x or y are true.
